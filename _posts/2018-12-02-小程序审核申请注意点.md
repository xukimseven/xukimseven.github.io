---
layout: post
title:  "小程序审核注意点"
date:   2018-12-02 18:35:13
tags:
- html
- js
- css
- 前端设计
- 微信小程序
- 工作总结
description: ''
color: 'rgb(255,210,32)'
cover: 'http://blogimg.since1105.wang/testGif.gif'
---

# 小程序审核注意点

​	最近有点恍惚，一不小心又是几个月过去了。我徐汉三又回来了。

​	2018-12-02，今天距离我离开上一家公司有加入另一个团队也是过去了一个多月了。10月16号正式离职上家公司，10月22号正式以实习生身份加入“XX”大家庭。在XX事业部担任前端开发的职务。

​	一个多月以来，在被大佬的碾压与“嘲讽”下，多多少少是持续进步的。在这里，我是真的明白了，别人比你优秀，还比你努力。。。。我的昊哥啊，你走路是真的快，我跟的确实是费劲的。不过我会努力不掉队的。。。

​	在公司里的第一个任务就是完成小程序部分的开发。在开发中，我感觉到小程序的审核是越来越繁琐麻烦了。各种的挑刺找问题。审核一次大半天出个结果，往往还不通过。下面是最近审核和开发中踩的坑。

## （一）关于审核

> 1:服务类目"教育-在线教育_"与你提交代码审核时设置的功能页面内容不一致:
> (1):你好，你的小程序涉及直播，请补充选择社交-直播类目，或自查代码，确保包括前端展示、小程序代码等整体均移除相关内容，再提交代码审核。
>
> ——2018-10-30 （由于缺少《网络文化经营许可证》）
>
> 1:小程序内容不符合规则:
> (1):请在小程序服务页面上架正式（非测试）内容或商品后重新提交审核。（测试环境wifi，Andriod 8.0.0，微信6.7.2，Honor 8 Lite）
>
> ——2018-11-07 （由于页面显示的数据均为测试数据，所以不过审）
>
> 1:小程序内容不符合规则:
> (1):小程序页面内容涉及提供【电子课程】等虚拟产品购买，并可在线完成支付，属于虚拟产品购买，iOS系统暂不支持。
>
> ——2018-11-08 （由于iOS上架虚拟产品）
>
> 1:小程序内容不符合规则:
> (1):小程序页面内容涉及：购买虚拟产品且含价格展示，ios系统暂不支持，请移除：页面虚拟产品购买及价格展示板块内容后，再提交代码审核。
>
> ——2018-11-08 （由于iOS上架虚拟产品）
>
> 1:小程序内容不符合规则:
> (1):小程序页面内容涉及提供：【付费题库】虚拟产品内容，并可引导至“公众号”完成支付，属于虚拟产品购买，ios系统暂不支持，请移除虚拟商品购买功能后，再提交代码审核。
>
> ——2018-11-08 （由于iOS上架虚拟产品，且引导至公众号，小程序这也是不允许的）
>
> 1:小程序内容不符合规则:
> (1):小程序页面内容提示：iOS功能暂不支持，可修改文案为：“由于相关规范，iOS功能暂不可用”。
>
> ——2018-11-09 （由于iOS端的说明文案不好，需要改成他们提供的，所以不通过。。。。）
>
>
>
> PS：除去上述问题，小程序同样对分享很敏感，虽然有分享功能，但是安卓端存在拿不到分享成功失败的回调，而且官方不提倡过分的分享。



​	所以，就上面出现的各种问题，我们想了用后台开关的操作方式来解决这个问题。

### 一、通过后台开关打开和关闭小程序的ios支付按钮

后台提供字段，如 `show_ios: true || false`

​	前端小程序请求拿到课程数据针对每个课程的数据中，通过对设备和数据中 `show_ios` 的双重验证来对ios端显示和关闭ios购买按钮以及ios端的价格显示与关闭进行操作。

​	通过这种方式就解决的小程序ios断不可支付的问题。

​	在审核的时候直接关闭 `show_ios` 的开关，这时候审核员看到的界面显示为—— “由于相关规范，iOS功能暂不可用”。这里的文案同样需要注意，因为文案不规范也被退审过。详情见上方 `2018-11-09`。

​	在过审后，打开 `show_ios` 开关，此时就可以正常的进行ios端购买课程的服务了。

​	需要注意的是，这个设定最好只对 ios 端起作用。在安卓上，是无论开关的打开或关闭，都可进行购买操作。所以，在小程序中需要验证设备的系统型号，是安卓 或 ios。

### 二、通过后台开关打开或关闭小程序分享引导

后端提供字段，如 `show_share: true ||false`

​	前端拿到字段同样进行判断是否显示分享页面或分享按钮。

​	该开关对ios和安卓应该都起作用。

### 不多讲了

​	反正我现在是真的了解到了牛人的开发方式。就是尽量将前端作为一个渲染引擎。将所有的页面显示后由后端控制，将前端视为模块，无需再次进行前端开发，什么时间段前端拿到什么数据显示什么模块。这是我现在看来最佳的开发方式了。可能是我讲的比较俗气，但这是我的最直观感受。

## （二）关于开发

### 这里要重点讲一讲——组件的生命周期

​	官方文档：[点击查看](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html)

> - 组件实例刚刚被创建好时， `created` 生命周期被触发。此时，组件数据 `this.data` 就是在 `Component` 构造器中定义的数据 `data` 。 **此时还不能调用 setData 。** 通常情况下，这个生命周期只应该用于给组件 `this` 添加一些自定义属性字段。
> - 在组件完全初始化完毕、进入页面节点树后， `attached` 生命周期被触发。此时， `this.data` 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行。
> - 在组件离开页面节点树后， `detached` 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 `detached` 会被触发。

| 生命周期 | 参数           | 描述                                     |
| -------- | -------------- | ---------------------------------------- |
| created  | 无             | 在组件实例刚刚被创建时执行               |
| attached | 无             | 在组件实例进入页面节点树时执行           |
| ready    | 无             | 在组件在视图层布局完成后执行             |
| moved    | 无             | 在组件实例被移动到节点树另一个位置时执行 |
| detached | 无             | 在组件实例被从页面节点树移除时执行       |
| error    | `Object Error` | 每当组件方法抛出错误时执行               |

​	在开发中发现组件的生命周期比调用者的生命周期要更早的进行。就是说，`created`和`attached`在进入页面后最先执行，这是要比也调用者的 `onload` 要更早的执行的。在开发中，这是个巨坑啊。当初文档看的不清，让我掉进了坑里，让组件有了自己的‘灵魂’和‘大脑’。

​	解决办法：用 `ready`取代 `created`和`attached` 或者 在父级中调用组件的方法，以此将组件 ‘无脑化’，任凭父级调用。

------

​	最近睡眠一直不好，下了个蜗牛睡眠，睡眠年龄平均都在50岁左右吧。一个软件把我的一个妙龄青年看的这么老，好气啊。

​	以后啊还是要好好睡觉，也要好好记录学习的问题和解决方案，不然我真是觉得我的进步太慢的。。。。我好气我自己啊。。。。

------

​	下周，开题答辩，好好写开题论文去了。。。